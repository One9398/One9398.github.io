<!doctype html>



  


<html class="theme-next pisces use-motion">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />












  
  
  <link href="/vendors/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/vendors/font-awesome/css/font-awesome.min.css?v=4.4.0" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.0.1" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, Word" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.0.1" />






<meta name="description" content="You Don’t Know JS: Scope &amp;amp; ClosuresChapter 2: Lexical ScopeIn Chapter 1, we defined “scope” as the set of rules that govern how the Engine can look up a variable by its identifier name and find it">
<meta property="og:type" content="article">
<meta property="og:title" content="One Word">
<meta property="og:url" content="http://www.yoursite.com/2016/09/08/Chapter 2: Lexical Scope  /index.html">
<meta property="og:site_name" content="One Word">
<meta property="og:description" content="You Don’t Know JS: Scope &amp;amp; ClosuresChapter 2: Lexical ScopeIn Chapter 1, we defined “scope” as the set of rules that govern how the Engine can look up a variable by its identifier name and find it">
<meta property="og:image" content="http://o9or2y9io.bkt.clouddn.com/2016-09-08-fig2.png">
<meta property="og:updated_time" content="2016-09-08T14:25:51.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="One Word">
<meta name="twitter:description" content="You Don’t Know JS: Scope &amp;amp; ClosuresChapter 2: Lexical ScopeIn Chapter 1, we defined “scope” as the set of rules that govern how the Engine can look up a variable by its identifier name and find it">
<meta name="twitter:image" content="http://o9or2y9io.bkt.clouddn.com/2016-09-08-fig2.png">



<script type="text/javascript" id="hexo.configuration">
  var NexT = window.NexT || {};
  var CONFIG = {
    scheme: 'Pisces',
    sidebar: {"position":"left","display":"always"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: 0,
      author: '博主'
    }
  };
</script>




  <link rel="canonical" href="http://www.yoursite.com/2016/09/08/Chapter 2: Lexical Scope  /"/>

  <title>  | One Word </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  



  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "//hm.baidu.com/hm.js?3c396973af53afd346011bcf3bf4af43";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>








  
  
    
  

  <div class="container one-collumn sidebar-position-left page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">One Word</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle">Never too old to learn.</p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2016-09-08T22:25:51+08:00" content="2016-09-08">
              2016-09-08
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/09/08/Chapter 2: Lexical Scope  /#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/09/08/Chapter 2: Lexical Scope  /" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="You-Don’t-Know-JS-Scope-amp-Closures"><a href="#You-Don’t-Know-JS-Scope-amp-Closures" class="headerlink" title="You Don’t Know JS: Scope &amp; Closures"></a>You Don’t Know JS: Scope &amp; Closures</h1><h1 id="Chapter-2-Lexical-Scope"><a href="#Chapter-2-Lexical-Scope" class="headerlink" title="Chapter 2: Lexical Scope"></a>Chapter 2: Lexical Scope</h1><p>In Chapter 1, we defined “scope” as the set of rules that govern how the <em>Engine</em> can look up a variable by its identifier name and find it, either in the current <em>Scope</em>, or in any of the <em>Nested Scopes</em> it’s contained within.</p>
<p>There are two predominant models for how scope works. The first of these is by far the most common, used by the vast majority of programming languages. It’s called <strong>Lexical Scope</strong>, and we will examine it in-depth. The other model, which is still used by some languages (such as Bash scripting, some modes in Perl, etc.) is called <strong>Dynamic Scope</strong>.</p>
<p>Dynamic Scope is covered in Appendix A. I mention it here only to provide a contrast with Lexical Scope, which is the scope model that JavaScript employs.</p>
<h2 id="Lex-time"><a href="#Lex-time" class="headerlink" title="Lex-time"></a>Lex-time</h2><p>As we discussed in Chapter 1, the first traditional phase of a standard language compiler is called lexing (aka, tokenizing). If you recall, the lexing process examines a string of source code characters and assigns semantic meaning to the tokens as a result of some stateful parsing.</p>
<p>It is this concept which provides the foundation to understand what lexical scope is and where the name comes from.</p>
<p>To define it somewhat circularly, lexical scope is scope that is defined at lexing time. In other words, lexical scope is based on where variables and blocks of scope are authored, by you, at write time, and thus is (mostly) set in stone by the time the lexer processes your code.</p>
<p><strong>Note:</strong> We will see in a little bit there are some ways to cheat lexical scope, thereby modifying it after the lexer has passed by, but these are frowned upon. It is considered best practice to treat lexical scope as, in fact, lexical-only, and thus entirely author-time in nature.</p>
<p>Let’s consider this block of code:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">a</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> b = a * <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params">c</span>) </span>&#123;</span><br><span class="line">		<span class="built_in">console</span>.log( a, b, c );</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	bar(b * <span class="number">3</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo( <span class="number">2</span> ); <span class="comment">// 2 4 12</span></span><br></pre></td></tr></table></figure>
<p>There are three nested scopes inherent in this code example. It may be helpful to think about these scopes as bubbles inside of each other.</p>
<p><img src="http://o9or2y9io.bkt.clouddn.com/2016-09-08-fig2.png" width="500"></p>
<p><strong>Bubble 1</strong> encompasses the global scope, and has just one identifier in it: <code>foo</code>.</p>
<p><strong>Bubble 2</strong> encompasses the scope of <code>foo</code>, which includes the three identifiers: <code>a</code>, <code>bar</code> and <code>b</code>.</p>
<p><strong>Bubble 3</strong> encompasses the scope of <code>bar</code>, and it includes just one identifier: <code>c</code>.</p>
<p>Scope bubbles are defined by where the blocks of scope are written, which one is nested inside the other, etc. In the next chapter, we’ll discuss different units of scope, but for now, let’s just assume that each function creates a new bubble of scope.</p>
<p>The bubble for <code>bar</code> is entirely contained within the bubble for <code>foo</code>, because (and only because) that’s where we chose to define the function <code>bar</code>.</p>
<p>Notice that these nested bubbles are strictly nested. We’re not talking about Venn diagrams where the bubbles can cross boundaries. In other words, no bubble for some function can simultaneously exist (partially) inside two other outer scope bubbles, just as no function can partially be inside each of two parent functions.</p>
<h3 id="Look-ups"><a href="#Look-ups" class="headerlink" title="Look-ups"></a>Look-ups</h3><p>The structure and relative placement of these scope bubbles fully explains to the <em>Engine</em> all the places it needs to look to find an identifier.</p>
<p>In the above code snippet, the <em>Engine</em> executes the <code>console.log(..)</code> statement and goes looking for the three referenced variables <code>a</code>, <code>b</code>, and <code>c</code>. It first starts with the innermost scope bubble, the scope of the <code>bar(..)</code> function. It won’t find <code>a</code> there, so it goes up one level, out to the next nearest scope bubble, the scope of <code>foo(..)</code>. It finds <code>a</code> there, and so it uses that <code>a</code>. Same thing for <code>b</code>. But <code>c</code>, it does find inside of <code>bar(..)</code>.</p>
<p>Had there been a <code>c</code> both inside of <code>bar(..)</code> and inside of <code>foo(..)</code>, the <code>console.log(..)</code> statement would have found and used the one in <code>bar(..)</code>, never getting to the one in <code>foo(..)</code>.</p>
<p><strong>Scope look-up stops once it finds the first match</strong>. The same identifier name can be specified at multiple layers of nested scope, which is called “shadowing” (the inner identifier “shadows” the outer identifier). Regardless of shadowing, scope look-up always starts at the innermost scope being executed at the time, and works its way outward/upward until the first match, and stops.</p>
<p><strong>Note:</strong> Global variables are also automatically properties of the global object (<code>window</code> in browsers, etc.), so it <em>is</em> possible to reference a global variable not directly by its lexical name, but instead indirectly as a property reference of the global object.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.a</span><br></pre></td></tr></table></figure>
<p>This technique gives access to a global variable which would otherwise be inaccessible due to it being shadowed. However, non-global shadowed variables cannot be accessed.</p>
<p>No matter <em>where</em> a function is invoked from, or even <em>how</em> it is invoked, its lexical scope is <strong>only</strong> defined by where the function was declared.</p>
<p>The lexical scope look-up process <em>only</em> applies to first-class identifiers, such as the <code>a</code>, <code>b</code>, and <code>c</code>. If you had a reference to <code>foo.bar.baz</code> in a piece of code, the lexical scope look-up would apply to finding the <code>foo</code> identifier, but once it locates that variable, object property-access rules take over to resolve the <code>bar</code> and <code>baz</code> properties, respectively.</p>
<h2 id="Cheating-Lexical"><a href="#Cheating-Lexical" class="headerlink" title="Cheating Lexical"></a>Cheating Lexical</h2><p>If lexical scope is defined only by where a function is declared, which is entirely an author-time decision, how could there possibly be a way to “modify” (aka, cheat) lexical scope at run-time?</p>
<p>JavaScript has two such mechanisms. Both of them are equally frowned-upon in the wider community as bad practices to use in your code. But the typical arguments against them are often missing the most important point: <strong>cheating lexical scope leads to poorer performance.</strong></p>
<p>Before I explain the performance issue, though, let’s look at how these two mechanisms work.</p>
<h3 id="eval"><a href="#eval" class="headerlink" title="eval"></a><code>eval</code></h3><p>The <code>eval(..)</code> function in JavaScript takes a string as an argument, and treats the contents of the string as if it had actually been authored code at that point in the program. In other words, you can programmatically generate code inside of your authored code, and run the generated code as if it had been there at author time.</p>
<p>Evaluating <code>eval(..)</code> (pun intended) in that light, it should be clear how <code>eval(..)</code> allows you to modify the lexical scope environment by cheating and pretending that author-time (aka, lexical) code was there all along.</p>
<p>On subsequent lines of code after an <code>eval(..)</code> has executed, the <em>Engine</em> will not “know” or “care” that the previous code in question was dynamically interpreted and thus modified the lexical scope environment. The <em>Engine</em> will simply perform its lexical scope look-ups as it always does.</p>
<p>Consider the following code:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">str, a</span>) </span>&#123;</span><br><span class="line">	<span class="built_in">eval</span>( str ); <span class="comment">// cheating!</span></span><br><span class="line">	<span class="built_in">console</span>.log( a, b );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> b = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">foo( <span class="string">"var b = 3;"</span>, <span class="number">1</span> ); <span class="comment">// 1, 3</span></span><br></pre></td></tr></table></figure>
<p>The string <code>&quot;var b = 3;&quot;</code> is treated, at the point of the <code>eval(..)</code> call, as code that was there all along. Because that code happens to declare a new variable <code>b</code>, it modifies the existing lexical scope of <code>foo(..)</code>. In fact, as mentioned above, this code actually creates variable <code>b</code> inside of <code>foo(..)</code> that shadows the <code>b</code> that was declared in the outer (global) scope.</p>
<p>When the <code>console.log(..)</code> call occurs, it finds both <code>a</code> and <code>b</code> in the scope of <code>foo(..)</code>, and never finds the outer <code>b</code>. Thus, we print out “1, 3” instead of “1, 2” as would have normally been the case.</p>
<p><strong>Note:</strong> In this example, for simplicity’s sake, the string of “code” we pass in was a fixed literal. But it could easily have been programmatically created by adding characters together based on your program’s logic. <code>eval(..)</code> is usually used to execute dynamically created code, as dynamically evaluating essentially static code from a string literal would provide no real benefit to just authoring the code directly.</p>
<p>By default, if a string of code that <code>eval(..)</code> executes contains one or more declarations (either variables or functions), this action modifies the existing lexical scope in which the <code>eval(..)</code> resides. Technically, <code>eval(..)</code> can be invoked “indirectly”, through various tricks (beyond our discussion here), which causes it to instead execute in the context of the global scope, thus modifying it. But in either case, <code>eval(..)</code> can at runtime modify an author-time lexical scope.</p>
<p><strong>Note:</strong> <code>eval(..)</code> when used in a strict-mode program operates in its own lexical scope, which means declarations made inside of the <code>eval()</code> do not actually modify the enclosing scope.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">str</span>) </span>&#123;</span><br><span class="line"><span class="meta">   "use strict"</span>;</span><br><span class="line">   <span class="built_in">eval</span>( str );</span><br><span class="line">   <span class="built_in">console</span>.log( a ); <span class="comment">// ReferenceError: a is not defined</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo( <span class="string">"var a = 2"</span> );</span><br></pre></td></tr></table></figure>
<p>There are other facilities in JavaScript which amount to a very similar effect to <code>eval(..)</code>. <code>setTimeout(..)</code> and <code>setInterval(..)</code> <em>can</em> take a string for their respective first argument, the contents of which are <code>eval</code>uated as the code of a dynamically-generated function. This is old, legacy behavior and long-since deprecated. Don’t do it!</p>
<p>The <code>new Function(..)</code> function constructor similarly takes a string of code in its <strong>last</strong> argument to turn into a dynamically-generated function (the first argument(s), if any, are the named parameters for the new function). This function-constructor syntax is slightly safer than <code>eval(..)</code>, but it should still be avoided in your code.</p>
<p>The use-cases for dynamically generating code inside your program are incredibly rare, as the performance degradations are almost never worth the capability.</p>
<h3 id="with"><a href="#with" class="headerlink" title="with"></a><code>with</code></h3><p>The other frowned-upon (and now deprecated!) feature in JavaScript which cheats lexical scope is the <code>with</code> keyword. There are multiple valid ways that <code>with</code> can be explained, but I will choose here to explain it from the perspective of how it interacts with and affects lexical scope.</p>
<p><code>with</code> is typically explained as a short-hand for making multiple property references against an object <em>without</em> repeating the object reference itself each time.</p>
<p>For example:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">	a: <span class="number">1</span>,</span><br><span class="line">	b: <span class="number">2</span>,</span><br><span class="line">	c: <span class="number">3</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// more "tedious" to repeat "obj"</span></span><br><span class="line">obj.a = <span class="number">2</span>;</span><br><span class="line">obj.b = <span class="number">3</span>;</span><br><span class="line">obj.c = <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// "easier" short-hand</span></span><br><span class="line"><span class="keyword">with</span> (obj) &#123;</span><br><span class="line">	a = <span class="number">3</span>;</span><br><span class="line">	b = <span class="number">4</span>;</span><br><span class="line">	c = <span class="number">5</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>However, there’s much more going on here than just a convenient short-hand for object property access. Consider:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">with</span> (obj) &#123;</span><br><span class="line">		a = <span class="number">2</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> o1 = &#123;</span><br><span class="line">	a: <span class="number">3</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> o2 = &#123;</span><br><span class="line">	b: <span class="number">3</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">foo( o1 );</span><br><span class="line"><span class="built_in">console</span>.log( o1.a ); <span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line">foo( o2 );</span><br><span class="line"><span class="built_in">console</span>.log( o2.a ); <span class="comment">// undefined</span></span><br><span class="line"><span class="built_in">console</span>.log( a ); <span class="comment">// 2 -- Oops, leaked global!</span></span><br></pre></td></tr></table></figure>
<p>In this code example, two objects <code>o1</code> and <code>o2</code> are created. One has an <code>a</code> property, and the other does not. The <code>foo(..)</code> function takes an object reference <code>obj</code> as an argument, and calls <code>with (obj) { .. }</code> on the reference. Inside the <code>with</code> block, we make what appears to be a normal lexical reference to a variable <code>a</code>, an LHS reference in fact (see Chapter 1), to assign to it the value of <code>2</code>.</p>
<p>When we pass in <code>o1</code>, the <code>a = 2</code> assignment finds the property <code>o1.a</code> and assigns it the value <code>2</code>, as reflected in the subsequent <code>console.log(o1.a)</code> statement. However, when we pass in <code>o2</code>, since it does not have an <code>a</code> property, no such property is created, and <code>o2.a</code> remains <code>undefined</code>.</p>
<p>But then we note a peculiar side-effect, the fact that a global variable <code>a</code> was created by the <code>a = 2</code> assignment. How can this be?</p>
<p>The <code>with</code> statement takes an object, one which has zero or more properties, and <strong>treats that object as if <em>it</em> is a wholly separate lexical scope</strong>, and thus the object’s properties are treated as lexically defined identifiers in that “scope”.</p>
<p><strong>Note:</strong> Even though a <code>with</code> block treats an object like a lexical scope, a normal <code>var</code> declaration inside that <code>with</code> block will not be scoped to that <code>with</code> block, but instead the containing function scope.</p>
<p>While the <code>eval(..)</code> function can modify existing lexical scope if it takes a string of code with one or more declarations in it, the <code>with</code> statement actually creates a <strong>whole new lexical scope</strong> out of thin air, from the object you pass to it.</p>
<p>Understood in this way, the “scope” declared by the <code>with</code> statement when we passed in <code>o1</code> was <code>o1</code>, and that “scope” had an “identifier” in it which corresponds to the <code>o1.a</code> property. But when we used <code>o2</code> as the “scope”, it had no such <code>a</code> “identifier” in it, and so the normal rules of LHS identifier look-up (see Chapter 1) occurred.</p>
<p>Neither the “scope” of <code>o2</code>, nor the scope of <code>foo(..)</code>, nor the global scope even, has an <code>a</code> identifier to be found, so when <code>a = 2</code> is executed, it results in the automatic-global being created (since we’re in non-strict mode).</p>
<p>It is a strange sort of mind-bending thought to see <code>with</code> turning, at runtime, an object and its properties into a “scope” <em>with</em> “identifiers”. But that is the clearest explanation I can give for the results we see.</p>
<p><strong>Note:</strong> In addition to being a bad idea to use, both <code>eval(..)</code> and <code>with</code> are affected (restricted) by Strict Mode. <code>with</code> is outright disallowed, whereas various forms of indirect or unsafe <code>eval(..)</code> are disallowed while retaining the core functionality.</p>
<h3 id="Performance"><a href="#Performance" class="headerlink" title="Performance"></a>Performance</h3><p>Both <code>eval(..)</code> and <code>with</code> cheat the otherwise author-time defined lexical scope by modifying or creating new lexical scope at runtime.</p>
<p>So, what’s the big deal, you ask? If they offer more sophisticated functionality and coding flexibility, aren’t these <em>good</em> features? <strong>No.</strong></p>
<p>The JavaScript <em>Engine</em> has a number of performance optimizations that it performs during the compilation phase. Some of these boil down to being able to essentially statically analyze the code as it lexes, and pre-determine where all the variable and function declarations are, so that it takes less effort to resolve identifiers during execution.</p>
<p>But if the <em>Engine</em> finds an <code>eval(..)</code> or <code>with</code> in the code, it essentially has to <em>assume</em> that all its awareness of identifier location may be invalid, because it cannot know at lexing time exactly what code you may pass to <code>eval(..)</code> to modify the lexical scope, or the contents of the object you may pass to <code>with</code> to create a new lexical scope to be consulted.</p>
<p>In other words, in the pessimistic sense, most of those optimizations it <em>would</em> make are pointless if <code>eval(..)</code> or <code>with</code> are present, so it simply doesn’t perform the optimizations <em>at all</em>.</p>
<p>Your code will almost certainly tend to run slower simply by the fact that you include an <code>eval(..)</code> or <code>with</code> anywhere in the code. No matter how smart the <em>Engine</em> may be about trying to limit the side-effects of these pessimistic assumptions, <strong>there’s no getting around the fact that without the optimizations, code runs slower.</strong></p>
<h2 id="Review-TL-DR"><a href="#Review-TL-DR" class="headerlink" title="Review (TL;DR)"></a>Review (TL;DR)</h2><p>Lexical scope means that scope is defined by author-time decisions of where functions are declared. The lexing phase of compilation is essentially able to know where and how all identifiers are declared, and thus predict how they will be looked-up during execution.</p>
<p>Two mechanisms in JavaScript can “cheat” lexical scope: <code>eval(..)</code> and <code>with</code>. The former can modify existing lexical scope (at runtime) by evaluating a string of “code” which has one or more declarations in it. The latter essentially creates a whole new lexical scope (again, at runtime) by treating an object reference <em>as</em> a “scope” and that object’s properties as scoped identifiers.</p>
<p>The downside to these mechanisms is that it defeats the <em>Engine</em>‘s ability to perform compile-time optimizations regarding scope look-up, because the <em>Engine</em> has to assume pessimistically that such optimizations will be invalid. Code <em>will</em> run slower as a result of using either feature. <strong>Don’t use them.</strong></p>

      
    </div>

    <div>
      
        
      
    </div>

    <div>
      
        

      
    </div>

    <footer class="post-footer">
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2016/09/08/记《Position in CSS》/" rel="next" title="记《Position in CSS》">
                <i class="fa fa-chevron-left"></i> 记《Position in CSS》
              </a>
            
          </div>

          <div class="post-nav-prev post-nav-item">
            
          </div>
        </div>
      

      
      
    </footer>
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          
  <div class="comments" id="comments">
    
      <div class="ds-thread" data-thread-key="2016/09/08/Chapter 2: Lexical Scope  /"
           data-title="" data-url="http://www.yoursite.com/2016/09/08/Chapter 2: Lexical Scope  /">
      </div>
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel ">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="https://avatars2.githubusercontent.com/u/17493209?v=3&u=fc0d3d59931920d0724ad6ac8d7a5312b15920d2&s=140"
               alt="One" />
          <p class="site-author-name" itemprop="name">One</p>
          <p class="site-description motion-element" itemprop="description">Keep learning, keep going.</p>
        </div>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">14</span>
              <span class="site-state-item-name">日志</span>
            </a>
          </div>

          
            <div class="site-state-item site-state-categories">
              <a href="/categories">
                <span class="site-state-item-count">2</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            <div class="site-state-item site-state-tags">
              <a href="/tags">
                <span class="site-state-item-count">5</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

      </section>

      
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">
            
              
            
            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#You-Don’t-Know-JS-Scope-amp-Closures"><span class="nav-number">1.</span> <span class="nav-text">You Don’t Know JS: Scope & Closures</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Chapter-2-Lexical-Scope"><span class="nav-number">2.</span> <span class="nav-text">Chapter 2: Lexical Scope</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Lex-time"><span class="nav-number">2.1.</span> <span class="nav-text">Lex-time</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Look-ups"><span class="nav-number">2.1.1.</span> <span class="nav-text">Look-ups</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Cheating-Lexical"><span class="nav-number">2.2.</span> <span class="nav-text">Cheating Lexical</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#eval"><span class="nav-number">2.2.1.</span> <span class="nav-text">eval</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#with"><span class="nav-number">2.2.2.</span> <span class="nav-text">with</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Performance"><span class="nav-number">2.2.3.</span> <span class="nav-text">Performance</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Review-TL-DR"><span class="nav-number">2.3.</span> <span class="nav-text">Review (TL;DR)</span></a></li></ol></li></ol></div>
            
          </div>
        </section>
      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2016</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">One</span>
</div>

<div class="powered-by">
  由 <a class="theme-link" href="http://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Pisces
  </a>
</div>

        

        
      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  



  
  <script type="text/javascript" src="/vendors/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/vendors/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/vendors/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.0.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.0.1"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.0.1"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.0.1"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.0.1"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.0.1"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.0.1"></script>



  

  
    
  

  <script type="text/javascript">
    var duoshuoQuery = {short_name:"one9398"};
    (function() {
      var ds = document.createElement('script');
      ds.type = 'text/javascript';ds.async = true;
      ds.id = 'duoshuo-script';
      ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
      ds.charset = 'UTF-8';
      (document.getElementsByTagName('head')[0]
      || document.getElementsByTagName('body')[0]).appendChild(ds);
    })();
  </script>

  
    
  






  
  
  

  

  

</body>
</html>
